Sujet disponible ici copier coller du site : http://web4.ensiie.fr/~guillaume.burel/cours/IPI/projet_2019.html


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <link rel="stylesheet" type="text/css"
   href="../../urbain_style.css">
   <TITLE>Projet prog. impérative</TITLE>
</HEAD>
<body>
<h1>
Programmation impérative, projet 2019/2020
</h1>
<h3>Dates et principe</h3>
Cette page peut être mise à jour, avec informations complémentaires,
précisions, <em><a href ="#bonus">questions
	bonus</a></em>, etc. Pensez à y revenir souvent.<br>

<p>Mise à jour le 22/11/2019&nbsp;: précision sur le dépilement d'une
  pile vide.
<p>Mise à jour le 25/11/2019&nbsp;: précision sur l'instruction <code>#</code>.
<p>Mise à jour le 28/11/2019&nbsp;: précisions sur les
  instructions <code>=</code>, <code>$</code> et <code>;</code>.
<p>Mise à jour le 02/12/2019&nbsp;: précisions sur les
  instructions <code>p</code> et <code>g</code>.
<p>Mise à jour le 16/12/2019&nbsp;: modification du programme
  d'exemple <a href="prog2d/sieve.p2d"><code>sieve.p2d</code></a> pour
  que le résultat obtenu soit plus lisible&nbsp;; il s'agit du crible
  d'Ératosthène qui affiche les nombres premiers jusqu'à 79.
<hr>
Projet à rendre pour le <b>06/01/2020</b> à <b>23h59</b>, aucun retard ne sera toléré.<br>
Des soutenances pourront être organisées ensuite.<br><br>

Lire tout le sujet.<br><br>

Un rendu de projet comprend :
<ul>
<li> Un rapport typographié précisant vos choix, les problèmes
  techniques qui se posent et les solutions trouvées ; il précise en
  conclusion les limites de votre programme. Le rapport sera de
  préférence composé avec <span style="font-family:serif;margin-right:-.7em">L<span style="font-size:0.9em;position:relative;top:-.1em;left:-0.4em;">A</span><span style="position:relative;left:-.5em;">T</span><span style="position:relative;top:.2em;left:-.6em;">E</span><span style="position:relative;left:-.7em;">X</span></span>. Le soin apporté à la grammaire et à
  l'orthographe est largement pris en compte.</li>
<li> Un code <em>abondamment</em> commenté ; la première partie des
  commentaires comportera systématiquement les lignes :<br>
<ol>
<li><tt>@ requires </tt> décrivant les préconditions : c'est-à-dire
conditions sur les paramètres pour une bonne utilisation (<b>pas de
  typage ici</b>),</li>
<li><tt>@ assigns </tt> listant les zones de mémoire modifiées,</li>
<li><tt>@ ensures </tt>  décrivant la propriété vraie à la sortie de la
fonction lorsque les préconditions sont respectées, le cas échéant
avec mention des comportements en cas de succès et en cas d'échec,</li>
</ol>
En outre chaque boucle <tt>while</tt> doit contenir un commentaire
précisant la raison de sa terminaison (le cas échéant).<br>  On pourra
préciser des informations additionnelles si des techniques
particulières méritent d'être mentionnées.
<br><br>
Le code doit enfin compiler sans erreur (évidemment) et sans warning lorsque
les options <tt>-Wall</tt> sont utilisées. <b>Un code qui ne compile pas
se verra attribuer la note de 0.</b></p></li>
<li>Un manuel d'utilisation de votre exécutable, même minimal, est toujours bienvenu.</li>
</ul>
Avez-vous lu tout le sujet ?

<hr>
<h4>Protocole de dépôt</h4>
<p>
  Vous devez rendre 
  <ul> 
    <li> Votre rapport (en pdf) et</li> 
    <li> Vos fichiers de code</li>
  </ul>
  rassemblés dans une archive tar gzippée identifiée
  comme <em>votre_prénom_votre_nom</em><tt>.tgz</tt>.<br>  La commande
  devrait ressembler à :<br>
  <tt>tar zcvf randolph_carter.tgz rapport.pdf fichiers.c
    autres_truc_éventuels.c</tt>&hellip;<br>
  <b>N'OUBLIEZ surtout PAS de mettre le nom identifiant l'archive</b>
  (donc nouveau) <b>en PREMIER.</b><br>
  <b>Lisez le man !</b> et testez le contenu de votre archive (une
  commande comme par exemple&nbsp;:<br> <tt>tar tvf
  randolph_carter.tgz</tt> doit lister les fichiers et donner leur
  taille).
  <ul>
    <li><b>Une archive qui ne contient pas les fichiers demandés ne
	sera pas excusable.</b></li>
    <li><b>**Une archive qui n'est pas au format demandé</b> (archive
    tar gzippée avec suffixe .tgz) <b>ne sera
	pas corrigée**</b> donc c'est 0/20.</li>
  </ul>
</p>
<p>Toute tentative de fraude (plagiat, etc.) sera sanctionnée. Si
  plusieurs projets ont <b>des sources trop
  similaires</b>, <em>tous</em> leurs auteurs se verront
attribuer la note 0/20. En particulier, il faudra prendre soin de ne
  pas publier son travail sur un dépôt public (en tout cas pas avant
  la date de fin de rendu).</p>
<p>
<b>Procédure de dépôt</b><br> Vous devez enregistrer
votre archive tgz dans le dépôt dédié au cours IPI (ipi-2019) en vous
connectant à <a href="http://exam.ensiie.fr">http://exam.ensiie.fr</a>. Ce dépôt sera ouvert
jusqu'au 6 janvier inclus.
</p>

<hr>

<h3>Contexte</h3>
<p>Le but de ce projet est d'implanter un interpréteur et un débogueur
  pour un langage de programmation en deux dimensions appelé <em>prog2d</em>.

<p>Un programme de ce langage est défini par une grille de caractères
  de largeur et de hauteur données. Un curseur se déplace sur cette
  grille en fonction des instructions données par le caractère sous le
  curseur, dans une des huit directions possibles (haut, bas, gauche,
  droite et les quatre diagonales).
  Ce curseur possède une inertie : sauf si l'instruction
  modifie sa direction, il continue à avancer dans la même.

<h3>Fonctionnement</h3>

<p>Initialement, le curseur est situé à la case en haut à gauche et
  il se déplace vers la droite.

<p>La grille est torique&nbsp;: si le curseur est sur la dernière
  colonne et qu'il se déplace à droite, il arrive sur la première
  colonne, et inversement&nbsp;; de même, si le curseur est sur la dernière
  ligne et qu'il se déplace en bas, il arrive sur la première
  ligne, et inversement.

<p>L'exécution repose sur l'utilisation d'une pile d'entier, qui au
  départ est vide. Si on essaie de dépiler une valeur sur la pile
  vide, on retournera 0.
  
<p>À chaque itération, on exécute l'instruction située sous le
  curseur, puis on le déplace. La sémantique des instructions est
  donnée par le tableau suivant&nbsp;:

<table style="border-collapse: collapse;" border="1">
<tr>
<th>Instr.
</th>
<th>Description
</th></tr>
<tr>
<td><code>+</code>
</td>
<td>Addition&nbsp;: On dépile deux entiers a et b, et on empile a+b
</td></tr>
<tr>
<td><code>-</code>
</td>
<td>Soustraction&nbsp;: On dépile deux entiers a puis b, et on empile b-a
</td></tr>
<tr>
<td><code>*</code>
</td>
<td>Multiplication&nbsp;: On dépile deux entiers a et b, et on empile a&times;b
</td></tr>
<tr>
<td><code>:</code>
</td>
<td>Division entière&nbsp;: On dépile deux entiers a puis b, et on
  empile la division euclidienne de b par a. Si a vaut 0, on empile 42.
</td></tr>
<tr>
<td><code>%</code>
</td>
<td>Reste&nbsp;: On dépile deux entiers a puis b, et on empile le reste
  de la division euclidienne de b par a. Si a vaut 0, on empile 0xbadc0de.
</td></tr>
<tr>
<td><code>!</code>
</td>
<td>Non logique&nbsp;: On dépile un entier. Si c'est 0 on empile 1,
  sinon on empile 0.
</td></tr>
<tr>
<td><code>`</code>
</td>
<td>Plus grand que&nbsp;: On dépile deux entiers a et b, et on empile
  1 si b&gt;a, 0 sinon.
</td></tr>
<tr>
<td><code>&gt;</code>
</td>
<td>Change la direction pour aller à droite.
</td></tr>
<tr>
<td><code>&lt;</code>
</td>
<td>Change la direction pour aller à gauche.
</td></tr>
<tr>
<td><code>^</code>
</td>
<td>Change la direction pour aller en haut.
</td></tr>
<tr>
<td><code>v</code>
</td>
<td>Change la direction pour aller en bas.
</td></tr>
<tr>
<td><code>?</code>
</td>
<td>Choisit une direction au hasard (diagonales comprises)
</td></tr>
<tr>
<td><code>'</code>
</td>
<td>Dépile un entier. Change la direction en fonction du reste de la
  division euclidienne de cet entier par 8&nbsp;:
  <table>
    <tr><td>7</td><td>0</td><td>1</td></tr>
    <tr><td>6</td><td>&nbsp;</td><td>2</td></tr>
    <tr><td>5</td><td>4</td><td>3</td></tr>
    </table>
</td></tr>
<tr>
<td><code>]</code>
</td>
<td>Tourne à gauche de 45°.
</td></tr>
<td><code>[</code>
</td>
<td>Tourne à droite de 45°.
</td></tr>
<tr>
<td><code>_</code>
</td>
<td>Conditionnelle horizontale&nbsp;: dépile un entier, change la
  direction vers la droite si c'est 0, vers la gauche sinon.
</td></tr>
<tr>
<td><code>|</code>
</td>
<td>Conditionnelle verticale&nbsp;: dépile un entier, change la
  direction vers le bas si c'est 0, vers le haut sinon.
</td></tr>
<tr>
<td><code>/</code>
</td>
<td>Conditionnelle diagonale&nbsp;: dépile un entier, change la
  direction vers le haut et la droite si c'est 0, vers le bas et la gauche sinon.
</td></tr>
<tr>
<td><code>\</code>
</td>
<td>Conditionnelle diagonale&nbsp;: dépile un entier, change la
  direction vers le bas et la droite si c'est 0, vers le haut et la gauche sinon.
</td></tr>
<tr>
<td><code>"</code>
</td>
<td>Passe en mode <em>chaîne de caractère</em>&nbsp;: empile la valeur
  ASCII de tous les caractères suivants dans la direction courante jusqu'à
  atteindre un autre <code>"</code>
</td></tr>
<tr>
<td><code>=</code>
</td>
<td>Duplique le sommet de la pile. Si la pile est vide, empile deux
  fois l'entier 0.
</td></tr>
<tr>
<td><code>$</code>
</td>
<td>Échange les deux valeurs au sommet de la pile. Si la pile contient
  un seul élément, empile l'entier 0 au-dessus. Si la pile est vide, empile deux
  fois l'entier 0.
</td></tr>
<tr>
<td><code>;</code>
</td>
<td>Retire la valeur au sommet de la pile. Sans effet si la pile est
  déjà vide.
</td></tr>
<tr>
<td><code>.</code>
</td>
<td>Dépile un entier et l'affiche comme un entier.
</td></tr>
<tr>
<td><code>,</code>
</td>
<td>Dépile un entier et affiche le caractère correspond au code ASCII
  de sa valeur tronquée à l'intervalle [0;255].
</td></tr>
<tr>
<td><code>#</code>
</td>
  <td>Pont&nbsp;: dépile un entier n et saute au-dessus des n prochains
  caractères (c'est-à-dire qu'on avance sans exécuter les instructions
  auxquelles ils correspondent éventuellement).
</td></tr>
<tr>
<td><code>g</code>
</td>
<td><em>Get</em>&nbsp;: dépile deux entiers x et y, et empile la
  valeur (code ASCII) de la grille à la position (x,y). Si la position est en
  dehors de la grille, empile 0.
</td></tr>
<tr>
<td><code>p</code>
</td>
<td><em>Put</em>&nbsp;: dépile trois entiers x, y et z, et écrit z
  (code ASCII de la valeur tronquée entre 0 et 255) dans la grille à la
  position (x,y). Si la position est en dehors de la grille, ne fait
  rien.
</td></tr>
<tr>
<td><code>&amp;</code>
</td>
<td>Demande à l'utilisateur d'entrer un entier, et empile cet entier.
</td></tr>
<tr>
<td><code>~</code>
</td>
<td>Demande à l'utilisateur d'entrer un caractère, et empile la valeur
  ASCII de ce caractère.
</td></tr>
<tr>
<td><code>@</code>
</td>
<td>Fin du programme.
</td></tr>
<tr>
<td><code>0</code> à <code>9</code>
</td>
<td>Empile l'entier correspondant.
</td></tr>
<tr>
<td><code>'&nbsp;'</code>
</td>
<td>Espace&nbsp;: Ne fait rien.
</td></tr>
</table>
  

<h3>Interpréteur</h3>

<p>Dans un premier temps, on va écrire un interpréteur, c'est-à-dire un
exécutable qui prend en argument le nom d'un fichier contenant un
programme prog2d, et qui exécute les instructions du programme jusqu'à
atteindre <code>@</code>.

<p>Si le nombre d'argument est plus petit que 1, on affichera un message
d'usage de l'exécutable, s'il est plus grand que 1 on ne considérera
que le premier.

<p>Un fichier contenant un programme prog2d sera composé d'une
  première ligne contenant deux entiers correspondant à la
  largeur <em>w</em> et
  la hauteur <em>h</em> de la grille, puis <em>h</em> lignes de
  longueur <em>w</em> qui correspondent au contenu de la grille.

<p>Vous trouverez <a href="prog2d/">dans ce répertoire</a> des
  exemples de fichiers contenant des programmes prog2d. Votre
  interpréteur devra impérativement tous les exécuter sans
  erreur. Lors de la correction, des tests avec d'autres programmes
  seront également effectués.
  
<h3>Débogueur</h3>

<p>On écrit maintenant un débogueur, c'est-à-dire un exécutable qui prend en argument le nom d'un fichier contenant un
programme prog2d, et qui va ensuite attendre des commandes entrées par
  l'utilisateur pour avancer dans le programme pas à pas, en affichant
  l'état du programme avant chaque entrée.

<p>Pour afficher l'état d'un programme, on va d'abord afficher la
  grille du programme (qui peut être modifiée par les
  instructions <code>p</code>). On entourera cette grille de repères
  et d'indicateurs pour indiquer où se trouve le curseur.

<p>On affiche ensuite l'état de la pile, en mettant le sommet à
  gauche, et en affichant pour chaque valeur, l'entier et entre
  parenthèse le caractère correspondant à son code ASCII (tronqué à
  l'intervalle [0;255]).

<p>On affiche enfin la position du curseur sous la
  forme <code>x: </code><em>n</em><code>, y: </code><em>m</em>.

<p>L'affichage attendu est donc de la forme:

<hr>
<pre>
   0    5    10   15   20   25   30   35   40   45   50   55   60   65   70   75   
   |    |    |  v |    |    |    |    |    |    |    |    |    |    |    |    | 
 0-vv  <      <                                                                 
       2                                                                        
      >^v v<                                                                    
    v1<?>3v4                                                                    
      >^<  ^<                                                                   
 5->  >?>  ?>5^                                                                 
      >v<  v<                                                                   
    v9<?>7v6                                                                    
      >v< v<                                                                    
       8                                                                        
10-    >  >   ^                                                                 
    vv  <      <                                                                
        2                                                                       
       >^v v<                                                                   
     v1<?>3v4                                                                   
15-    >^<  ^<                                                                  
    >  >?>  ?>5^                                                                
       >v<  v<     v          ,*25           <<                                 
     v9<?>7v6                                ,,                                 
       >v< v<                                ""                                 
20-     8                                    ><                                 
        >  >   ^                             ""v                                
  >  >*=.>0"!rebmun tupnI">=2#2,_;25*,=&=99p`|^<       _0"!niw uoY">=2#2,_;25*,@
         ^         <                         >=99g01-*+^                        

 98 (b) | 101 (e) | 114 (r) | 33 (!) | 0 (&#00) | 3 (&#03) ||

x: 22, y: 13
</pre>
<hr>

Dans un premier temps, les commandes que peuvent entrer l'utilisateur sont les
suivantes&nbsp;:
<ul>
  <li><code>step</code>&nbsp;: avance d'une étape, c'est-à-dire
  exécute l'instruction sous le curseur et déplace ce dernier.
  <li><code>step </code><em>n</em>&nbsp;: avance de <em>n</em>
  étape(s), c'est-à-dire répète <em>n</em> fois ce qui est décrit 
  précédemment.
  <li><code>run</code>&nbsp;: continue à exécuter le programme jusqu'à
  atteindre <code>@</code>.
  <li><code>restart</code>&nbsp;: retourne à l'état initial.
  <li><code>quit</code>&nbsp;: quitte le débogueur.
</ul>
Si l'utilisateur entre une ligne vide, il faut répéter la dernière
commande. (Donc, en entrant <code>step</code>, puis en appuyant
plusieurs fois sur entrée, on va avancer étape par étape dans le
programme.)

Avant chaque demande de commande à l'utilisateur, on affichera l'état
du programme comme indiqué ci-dessus.

<h4 id="bonus">Extensions</h4>

On ajoute les commandes suivantes&nbsp;:

<ul>
  <li><code>prec</code>&nbsp;: recule d'une étape, c'est-à-dire
    revient dans l'état précédent la dernière instruction.
  <li><code>prec </code><em>n</em>&nbsp;: recule de <em>n</em> étape(s).
  <li><code>breakpoint </code><em>x y</em>&nbsp;: ajoute un point
  d'arrêt à la position (<em>x</em>,<em>y</em>)&nbsp;; lors d'une
  commande ultérieure <code>run</code>, <code>step </code><em>n</em>
  ou <code>prec </code><em>n</em>, force l'arrêt si la position du curseur
  est dans la liste des points d'arrêts.
  <li><code>removebp </code><em>x y</em>&nbsp;: retire le point
  d'arrêt à la position (<em>x</em>,<em>y</em>)&nbsp;; sans effet si
  le point d'arrêt à cette position n'existait pas.
</ul>

  
<h3>Conseils</h3> Pour la récupération d'une entrée de 
l'utilisateur, on peut utiliser la suite de commandes suivantes&nbsp;:
<pre>
char buf[256];
 .
 .
 .
fgets(buf, 256, stdin);
sscanf(buf, "format", ...);
  ou
strncmp(buf, "debut", 5)
</pre>

Vous devez avoir lu jusqu'ici avant de commencer.

</body>
</html>
